---
title: "Tipping Point"
author: "Wanja James"
date: "7/13/2021"
output: slidy_presentation
---


```{r setup, include=FALSE}

libs <- c("dplyr","huxtable","foreign","haven","tidyr","stringr","ggplot2","lsmeans","emmeans","mice",
          "nlme", "broom", "broom.mixed","mitools")

lapply(libs, library, character.only=T)
# install.packages("mice")
# Generates Multivariate Imputations by Chained Equations (MICE)
# it uses the PMM method to impute the missing information. Predictive Mean Matching (PMM) is a semi-parametric imputation which is similar to regression except that value is randomly filled from among the observed donor values from an observation whose regression-predicted values are closest to the regression-predicted value for the missing value from the simulated regression model. By default five imputations are done for all missing values.
```

## Data setup

```{r,echo=T,warning=FALSE,error=F,message=F, comment=''}
# Read data-in

home <- "//na.jnj.com/rndusdfsroot/All/bnp/JNJ-67864238/DATACENTER_NA/PACRD2001/Docs/stat/Tipping point analysis/Arnold's work/Data"

example <- haven::read_sas(file.path(home,"example.sas7bdat"))%>% 
  dplyr::rename_with(tolower) %>%
  arrange(usubjid,avisitn)

# formating
example.1 <- example %>% 
  mutate(day = as.numeric(stringr::str_extract(avisit,"[0-9]+")),
         day_ =as.factor(day),
         trt01p_ = as.factor(trt01p),
         region1_ = as.factor(region1),
         olantdcl_ = as.factor(olantdcl),
         usubjid = as.factor(usubjid)
                                ) %>%
  select(usubjid,day,aval,base,chg, stage, ends_with("_"))
      

```


## Model 1

```{r,echo=T,warning=FALSE,error=F,message=F, comment=''}
# Model 1
library(nlme)
mod.1 <- nlme::lme(chg ~ base + trt01p_*day_ + region1_ + olantdcl_,           
               random = ~ day_|usubjid, control = lmeControl(opt='optim'),
               na.action = na.exclude,
               data = example.1)

# summary(mod.1)
# car::Anova(mod.1, type="II")  car::Anova(mod.1, type="III")

# ref.grid(mod.1)

# Ls means diff trt at visit 28
ls.mod1 <-emmeans(mod.1,"trt01p_",at=list(day_="28"))
confint(contrast(ls.mod1, "trt.vs.ctrl", ref = "Placebo"))

```


## Model 2

```{r,echo=T,warning=FALSE,error=F,message=F, comment=''}
## -- model 2
mod.2 <- nlme::gls(chg ~ base + trt01p_*day_ + region1_ + olantdcl_,  
               correlation = corSymm(form = ~ 1|usubjid),
               weights = varIdent(form = ~ 1|day_),
               na.action = na.exclude,
               data = example.1)

# Ls diff
ls.mod2 <-emmeans(mod.2,"trt01p_",at=list(day_="28"))
confint(contrast(ls.mod2, "trt.vs.ctrl", ref = "Placebo"))

```


## Model 3

- Unstructured covariance matrix [page 24](http://staff.pubhealth.ku.dk/~jufo/courses/rm2018/nlmePackage.pdf) 

```{r,echo=T,warning=FALSE,error=F,message=F, comment=''}
## -- model 3
mod.3 <- nlme::gls(chg ~ base + trt01p_*day_ + region1_ + olantdcl_,  
               correlation = corSymm(form = ~ as.numeric(day_)|usubjid),
               weights = varIdent(form = ~ 1|day_),
               na.action = na.exclude,
               data = example.1)
# summary(mod.3)

# Ls diff
ls.mod3 <-emmeans(mod.3,"trt01p_",at=list(day_="28"))
confint(contrast(ls.mod3, "trt.vs.ctrl", ref = "Placebo"))

```


##






## Missingness

While some quick fixes such as _mean-substitution_ may be fine in some cases, such simple approaches usually introduce **bias** into the data, for instance, applying mean substitution leaves the mean unchanged (which is desirable) but **decreases variance**, which may be undesirable.    


As far as **categorical variables** are concerned, replacing categorical variables is usually **not** advisable. Some common practice include replacing missing categorical variables with the _mode_ of the observed ones, however, it is questionable whether it is a good choice.



## Trying the imputation on the wide data


```{r,echo=T,warning=FALSE,error=F,message=F, comment=''}
# Transpose and check missingness pattern

ex.wide <- example.1 %>% pivot_wider(id_cols=c(usubjid,trt01p_,region1_,base,olantdcl_,stage),
                                     names_from=day,values_from=aval,names_prefix ="day_")

# subset by stage
ex.wide.st1 <- ex.wide %>% filter(stage==1)
ex.wide.st2 <- ex.wide %>% filter(stage==2)

# missing pattern
graphics.off()
md.pattern(ex.wide.st1, plot=T)


# MMRM on the incomplete data

mmrm.incomplete.st1 <- example.1 %>% filter(stage==1)

mod.st1<- nlme::gls(chg ~ base + trt01p_*day_ + region1_ + olantdcl_,  
               correlation = corSymm(form = ~ as.numeric(day_)|usubjid),
               weights = varIdent(form = ~ 1|day_),
               na.action = na.exclude, data = mmrm.incomplete.st1
     )

# Ls diff
ref_grid(mod.st1)
confint(contrast(emmeans(mod.st1,"trt01p_", at=list(day_="28")),
                 "trt.vs.ctrl", ref = "Placebo"))

```




```{r}
# impute. method = PMM
# methods(mice)
  # stage 1
imp.wide.st1 <- mice(ex.wide.st1, m = 50, maxit = 100, seed=234, printFlag = FALSE)

# 1)...
# you could place the code to reshape the data inside the with() block

long_st.1  <- with(imp.wide.st1, 
                   {
                     dat <- data.frame( usubjid = usubjid,
                                        trt01p_ = trt01p_,
                                        region1_ = region1_,
                                        olantdcl_ = olantdcl_,
                                        base = base,
                                        change_d2 = day_2-base,
                                        change_d8 = day_8-base,
                                        change_d15 = day_15-base,
                                        change_d22 = day_22-base,
                                        change_d28 = day_28-base
                     )
                    #- 
                    dat_long <- pivot_longer(dat,
                                             cols=contains("change"),
                                             names_to = "day", 
                                             values_to = "chg") %>% 
                      mutate(day_ = as.factor(as.numeric(stringr::str_extract(day,"[0-9]+"))))
                    
                    #-
                    nlme::gls(chg ~ base + trt01p_*day_ + region1_ + olantdcl_,
                                     correlation = corSymm(form = ~ as.numeric(day_)|usubjid),
                                     weights = varIdent(form = ~ 1|day_),
                                     na.action = na.exclude, 
                                     data = dat_long) 
                   }
                   )

summary(pool(long_st.1))

#---------#--------##--------##-

# you could place the code to reshape the data inside the with() block

long_st1.lme  <- with(imp.wide.st1, 
                   {
                     dat <- data.frame( usubjid = usubjid,
                                        trt01p_ = trt01p_,
                                        region1_ = region1_,
                                        olantdcl_ = olantdcl_,
                                        base = base,
                                        change_d2 = day_2-base,
                                        change_d8 = day_8-base,
                                        change_d15 = day_15-base,
                                        change_d22 = day_22-base,
                                        change_d28 = day_28-base
                     )
                    #- 
                    dat_long <- pivot_longer(dat,
                                             cols=contains("change"),
                                             names_to = "day", 
                                             values_to = "chg") %>% 
                      mutate(day_ = as.factor(as.numeric(stringr::str_extract(day,"[0-9]+"))))
                    
                    #-
                    models <- nlme::lme(chg ~ base + trt01p_*day_ + region1_ + olantdcl_,
                        random = ~ day_|usubjid, control = lmeControl(opt='optim'),
                        na.action = na.exclude, data=dat_long) 
 
                    #-
                    contrast(emmeans(models,"trt01p_",at=list(day_="28")),
                             "trt.vs.ctrl", ref = "Placebo")
                      }
                   )


summary(pool(long_st1.lme))

#---------#--------##--------##--------#

# 2)... 
# - use complete() to turn the imputed mids object into a dataframe containing the impute values, 
# - Reshape the dataframe into long format, turn it into a new mids object with as.mids(), 
# - Then fit the models with the new mids object

  # imp.wide.compl.st1 <- complete(imp.wide.st1, action = "all", include = FALSE)
imp.wide.compl.st1_ <- complete(imp.wide.st1, action = "long", include = F)


  # Reshape and Calculate CHG

imp.long.compl.st1 <- imp.wide.compl.st1_ %>% 
  pivot_longer(cols=contains("day_"),
               names_to = "day", 
               values_to = "aval") %>% 
  mutate(day_ = as.factor(as.numeric(stringr::str_extract(day,"[0-9]+"))),
         chg = aval - base
         )

  # fit by imp
mods.st1 <- imp.long.compl.st1 %>% group_by(.imp) %>% 
  do(models = nlme::gls(chg ~ base + trt01p_*day_ + region1_ + olantdcl_,
                        correlation = corSymm(form = ~ as.numeric(day_)|usubjid),
                        weights = varIdent(form = ~ 1|day_),
                        na.action = na.exclude, data=.) 
  )
# pool them together
summary(pool(mods.st1$models))
#emmeans(mods.st1$models[[1]],"trt01p_",at=list(day_="28"))

# -----***---*---*-*
# lme
mods.st1.lme <- imp.long.compl.st1 %>% group_by(.imp) %>% 
  do(models = nlme::lme(chg ~ base + trt01p_*day_ + region1_ + olantdcl_,
                        random = ~ day_|usubjid, control = lmeControl(opt='optim'),
                        na.action = na.exclude, data=.) 
  )

# pool them together
summary(pool(mods.st1.lme$models))

# Lsmeans
emmeans(mods.st1.lme$models[[1]],"trt01p_",at=list(day_="28"))
# Lsdiffs
confint(contrast(emmeans(mods.st1.lme$models[[50]],"trt01p_",at=list(day_="28")),
         "trt.vs.ctrl", ref = "Placebo"))

 #
contrast.st1.lsM <- vector(mode = "list", length = length(mods.st1.lme$models))
contrast.st1.intv <- contrast.st1.lme
contrast.st1.pval <- contrast.st1.lme

for (i in 1:length(mods.st1.lme$models)){
  
contrast.st1.lsM[[i]] <- emmeans(mods.st1.lme$models[[i]],
                                          "trt01p_", at=list(day_="28"))

contrast.st1.intv[[i]] <- confint(contrast(contrast.st1.lsM[[i]],"trt.vs.ctrl", ref = "Placebo"))

contrast.st1.pval[[i]] <- test(contrast(contrast.st1.lsM[[i]],"trt.vs.ctrl", ref = "Placebo"),
                               side = "<")
}

# 
summary(pool(contrast.st1.lsM))



# ---- -- # --
contrast.st1.intv <- as_tibble(confint(contrast(contrast.st1.lsM[[1]],"trt.vs.ctrl", 
                                                ref = "Placebo"))) %>% 
    mutate(imp = 1)

for(i in 2:length(mods.st1.lme$models)){
  contrast.st1.intv[i,]<- as_tibble(confint(contrast(contrast.st1.lsM[[i]],"trt.vs.ctrl", 
                                                ref = "Placebo"))) %>% 
    mutate(imp = i)
}




```




```{r}
#---------#--------##--------##-
# Delta 

# you could place the code to reshape the data inside the with() block

# which IDs we have imputes. Will help in adding Delta to only imputed values.(imputed values marker)

imputed <- as_tibble(imp.wide.st1[["where"]],rownames=".id") %>%
  select(`.id`,contains("day")) %>% 
  mutate(`.id`=as.numeric(`.id`)) %>% 
  pivot_longer(cols=contains("day"),names_to = "day", values_to = "imputed") 


# Get complete imputed dataset
delta.st1.comp <- complete(imp.wide.st1, action = "long", include = T)   


  # Reshape and Calculate CHG

delta.st1.long <- delta.st1.comp %>% 
  pivot_longer(cols=contains("day_"),
               names_to = "day", 
               values_to = "aval") %>% 
  mutate(day_ = as.factor(as.numeric(stringr::str_extract(day,"[0-9]+"))),
         chg = aval - base )

  # Merge. Imputed data + imputed values marker dataset

delta.st1.long.1 <- delta.st1.long %>% left_join(imputed,by=c(".id","day"))


#* ************************* MARGINAL DELTA ADJUSTMENTS ************** *******************************************/

#* Marginal delta adjustment: same delta applied to all visits for a treatment group */
#* Inputs: 	
#       - datasets with multiple imputed values after MCMC/regression and indicator if observed data was missing
# 			- Separate MI datasets for Stage 1 and Stage 2
# 			- maximum delta adjustment
# 			- increment for delta adjustment value
# 			- relationship between delta_placebo and delta_active 
# 				 # 1:delta_placebo=0; 
           # 2:delta_placebo=delta_active/2; 
           # 3:delta_placebo=delta_active 
# /* Output: - results_mar_delta_X dataset with pooled results for each delta_placebo and delta_active combination 
# 			X refers to the relationship code between delta_placebo and delta_active (1, 2, or 3) */
# /* Step 1: add appropriate deltas to imputed values
# /* Step 2: run MMRM on adjusted dataset - Stage 1 and Stage 2 separate
# /* Step 3: pool MMRM results  - Stage 1 and Stage 2 separate */
# /* Step 4: Combination test of pooled MMRM results and append to output data */
# /* Repeat Steps 1-4 until Maximum Delta or Tipping Point (delta s.t. result is not significant) is reached */


marginal.delta <- function(){
  
}

delta.active <- 1
delta.placebo <- 0 

 # add delta

delta.1 <- delta.st1.long.1 %>% 
  mutate(chg = case_when(trt01p_=="Placebo" & imputed==T  ~ chg-delta.placebo,
                         trt01p_=="Esketamine 56 mg" & imputed==T  ~ chg+delta.active,
                         TRUE ~ chg)
         )

  # fit by imp
delta.1.mods <- delta.1 %>% group_by(.imp) %>% 
  do(models = contrast(emmeans(nlme::lme(chg ~ base + trt01p_*day_ + region1_ + olantdcl_,
                        random = ~ day_|usubjid, control = lmeControl(opt='optim'),
                        na.action = na.exclude, data=.),
                        "trt01p_",at=list(day_="28")),
                       "trt.vs.ctrl", ref = "Placebo")
  )

# pool them together
summary(pool(delta.1.mods$models))

confint(contrast(emmeans(delta.1.mods$models[[50]],"trt01p_",at=list(day_="28")),
         "trt.vs.ctrl", ref = "Placebo"))


 


# Converting back to mids!!

delta.1.mids <- delta.1 %>% pivot_wider(id_cols=c(`.imp`,`.id`,usubjid,trt01p_,region1_,base,olantdcl_,stage),
                            names_from=day, values_from=chg) %>% as.mids()

#---------#--------##--------##--------#

```








```{r,echo=T,warning=FALSE,error=F,message=F, comment=''}

# Seperate Numerics and Factors 
ex.a <- example.1 %>% select(usubjid,chg,region1_,olantdcl_,trt01p_,day_)
ex.b <- example.1 %>% select(day,trt01pn,aval,base,stage) 


## Create MAR pattern
ex.b.MAR <- mice::ampute(ex.b)
# pattern of missing data
md.pattern(ex.b.MAR$amp)
ex.b.MAR$patterns

### **********************************************************
## Missing pattern with variables 
# Simulation of MAR pattern in AVAL with 30% missing, based on AVISIT(DAY), TRT01P, BASE, STAGE
  # patterns:
    # A matrix or data frame of size #patterns by #variables where 0 indicates that a variable should have        missing values and 1 indicates that a variable should remain complete.
mypattern <- c(1,1,0,1,1)
ex.b.MAR.2 <- ampute(ex.b,prop = 0.3, patterns = mypattern, mech = "MAR")
ex.b.MAR.M <- ex.b.MAR.2$amp
md.pattern(ex.b.MAR.M)

### **********************************************************
# Simulation of MNAR pattern in AVAL with 30% missing, based on AVISIT(DAY), TRT01P, BASE, STAGE

ex.b.MNAR.2 <- ampute(ex.b,prop = 0.3, patterns = mypattern, mech = "MNAR")
ex.b.MNAR.M <- ex.b.MNAR.2$amp
md.pattern(ex.b.MNAR.M)


### ----------------------------------------------------------------------
## Recombine Matrices

# Recombine the matrices from MNAR and MAR simulation with the variables
# that were seperated prior to simulation: USUBJID, CHG, REGION1, OLANTDCL

ex.MAR.Final <- cbind(ex.a, ex.b.MAR.M)
ex.MNAR.Final <- cbind(ex.a, ex.b.MNAR.M)
```




## Imputation

```{r,echo=T,warning=FALSE,error=F,message=F, comment=''}
## Impute missing data
# Multiple imputation for MAR data with creating 5 data sets

imp.MAR <- mice(ex.MAR.Final, m = 5, maxit = 10, seed=123,printFlag = FALSE)


# Multiple imputation for MNAR data with creating 5 data sets

imp.MNAR <- mice(ex.MNAR.Final, m= 5, maxit = 10, seed = 123,printFlag = FALSE)

```



##

```{r}

# mids-class: Multiply imputed data set (mids)

# create loop to do all constant delta adjustment to 
# Esketamine 56 mg for MAR.

# Esketamine 56 mg
imp.MAR.trt <- filter(imp.MAR, imp.MAR$data$trt01p_ == 'Esketamine 56 mg')

  # Delta
delta.trt = seq(0,20,by=1)

# allows me to run the function I put in `expr` exactly `n` times.
# Same Idea as using a For() loop
   # I will have 21 sets of the original imputed list
   
MAR.trt.rep = replicate(n=length(delta.trt), expr=imp.MAR.trt, simplify = FALSE)


# Loop through each of the 21 imputed lists and ADD delta to the imputed AVAL value
# i.e 1st set add delta=0,2nd set add delta=1, ..., last set add delta=20.

for (i in 1:length(delta.trt)){
  d.trt = delta.trt[i]
  MAR.trt.rep[[i]]$imp$aval = MAR.trt.rep[[i]]$imp$aval + delta.trt[i]
}

# name the list, 0:20
names(MAR.trt.rep) <- delta.trt



# ------------------------------------------------
# Placebo
imp.MAR.ctl <- filter(imp.MAR, imp.MAR$data$trt01p_ == 'Placebo')

  # Delta
delta.ctl <- seq(0,20,by=1)

# Replicate the imputed list
MAR.ctl.rep <- replicate(n=length(delta.ctl), expr=imp.MAR.ctl, simplify = FALSE)

# Loop through each of the 21 imputed lists and SUBTRACT delta to the imputed AVAL value
# i.e 1st set add delta=0,2nd set add delta=1, ..., last set add delta=20.

for (i in 1:length(delta.ctl)){
  d.ctl <- delta.ctl[i]
  MAR.ctl.rep[[i]]$imp$aval <- MAR.ctl.rep[[i]]$imp$aval - delta.ctl[i]
}

# name the list, 0:20
names(MAR.ctl.rep) <- delta.ctl

# Question.
#Range of delta. Should it be within the palusible values of aval. What if aval can only be +ve?
# observed range [0,53] 
 
```


##

Double loop to rbind all combinations between Esketamine 56 mg and
Placebo and place into a list for MAR.

```{r}

# Create a blank list as big as the combinatons of trt*ctl list. Help to collect the combinations
MAR.all.rep <- vector(mode="list", length=(length(delta.trt)*length(delta.ctl)))


# Stack/set: trt[i] & ctl[j]: where i=0,...,20.  & j=0,...,20.
##
k <-0 # initialize k

for (i in 1:length(delta.trt)){
  for (j in 1:length(delta.ctl)){
  k = k+1 
  MAR.all.rep[[k]] =  rbind(MAR.trt.rep[[i]], MAR.ctl.rep[[j]]) 
     }
}


## Create and attach names for the different combinations for MAR

delta.name <-vector(mode="list", length=(length(delta.trt)*length(delta.ctl)))

#  expand.grid : Create a data frame from all combinations of the supplied vectors or factors

delta.name <- apply(expand.grid(delta.trt,delta.ctl), 1, paste, collapse = " delta ctl & ")
delta.name.f <- paste(delta.name, "delta trt", sep = " ")
MAR.all.rep <- setNames(MAR.all.rep, delta.name.f)

```


Loop through list of delta adjustment values to change the list
from mids objects to dataframes to update the CHG variable after
imputation and delta adjustment for MAR.

```{r}
# initiate a null vector. Same size as MAR.all.rep
MAR.all.rep.comp <- vector(mode="list", length=(length(MAR.all.rep)))

# fills in the missing data, and returns the completed data after imputation

for (i in 1:length(MAR.all.rep)){
 
  MAR.all.rep.comp[[i]] <- complete(MAR.all.rep[[i]], action = "long", include = TRUE)
  # re-calculate chg
  MAR.all.rep.comp[[i]]$chg = MAR.all.rep.comp[[i]]$aval - MAR.all.rep.comp[[i]]$base
}



```


Change complete objects back to mids objects for MAR.

```{r}

for (i in 1:length(MAR.all.rep)){
  MAR.all.rep[[i]] = as.mids(MAR.all.rep.comp[[i]])
}

MAR.all.rep = setNames(MAR.all.rep, delta.name.f)



```


For MAR list of delta constant adjustments to chosen model.
1 GLS model

```{r}
MAR.fit <- vector(mode = "list",length=length(MAR.all.rep))

for (i in 1:length(MAR.fit)){
  MAR.fit[[i]] <-
        with(MAR.all.rep[[i]], gls(chg ~ base + trt01p_*day_ + region1_ + olantdcl_,  
               correlation = corSymm(form = ~ as.numeric(day_)|usubjid),
               weights = varIdent(form = ~ 1|day_),
               na.action = na.exclude))
}

MAR.fit <-  setNames(MAR.fit, delta.name.f)
```


Pool the analyzed data sets for MAR

```{r}
MAR.fit.pool <- vector(mode="list",length=length(MAR.fit))
  
for (i in 1:length(MAR.fit.pool)){
  MAR.fit.pool[[i]] <- pool(MAR.fit[[i]])
}


MAR.fit.pool <- setNames(MAR.fit.pool, delta.name.f)

```


Look at the pvalue for the main effect of treatment to find when the
pvalue is no longer significant.  Thus finding the tipping point for MAR.

```{r}
summary(MAR.fit.pool[[1]])
```

## MAR Function Based Delta Adjustment Heatmap

### Create dataframe that contains the p-values and delta values for Treatments 
### and Control for MAR data.

Create empty dataframe. 

```{r}
# Data frame with the stats



# Initialize a data frame

MAR.summary.est <- as_tibble(filter(summary(MAR.fit.pool[[1]]),term=="trt01p_Placebo")) %>% 
  mutate(ctl.trt= names(MAR.fit.pool)[1])

for(i in 2:length(MAR.fit.pool)){
  MAR.summary.est[i,]<- as_tibble(filter(summary(MAR.fit.pool[[i]]),term=="trt01p_Placebo")) %>% 
    mutate(ctl.trt= names(MAR.fit.pool)[i])
}


```

Fill in empty dataframe with pp-values for function based delta
adjustments for MAR.

```{r}

for(i in 1:length(pool.imp.all.func.delta.MAR)){
  MAR_pvals_func[i,1] = names(pool.imp.all.func.delta.MAR)[i]
  MAR_pvals_func[i,2] = summary(pool.imp.all.func.delta.MAR[[i]])[3,6]
}
```

Split the deltas into two variables for each delta for MAR.

```{r}
MAR_pvals_func = separate(data = MAR_pvals_func, col = V1, 
                           into = c("Placebo delta", "Esketamine 56 mg delta"),
                           sep = " & ")

MAR_pvals_func$`Placebo delta` = 
  as.numeric(str_extract(MAR_pvals_func$`Placebo delta`, "[0-9]+"))

MAR_pvals_func$`Esketamine 56 mg delta` = 
  as.numeric(str_extract(MAR_pvals_func$`Esketamine 56 mg delta`, "[0-9]+"))

colnames(MAR_pvals_func)[colnames(MAR_pvals_func) == "V2"] = "Pooled P-value"
```

Use ggplot2 package to create heatmap for function based delta MAR.

```{r}
ggplot(MAR_pvals_func, aes(x = `Placebo delta`, y = `Esketamine 56 mg delta`, 
                            fill = `Pooled P-value`)) + geom_tile()
```











